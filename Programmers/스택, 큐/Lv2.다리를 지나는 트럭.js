/*
문제 설명
트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다. 단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.
예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.

경과 시간	다리를 지난 트럭	다리를 건너는 트럭	대기 트럭
0	        []	              []	            [7,4,5,6]
1~2	        []	              [7]	            [4,5,6]
3	        [7]	              [4]	            [5,6]
4	        [7]	              [4,5]	            [6]
5	        [7,4]	          [5]	            [6]
6~7	        [7,4,5]	          [6]	            []
8	        [7,4,5,6]	      []	            []

따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.
solution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.

제한사항
- bridge_length는 1 이상 10,000 이하입니다.
- weight는 1 이상 10,000 이하입니다.
- truck_weights의 길이는 1 이상 10,000 이하입니다.
- 모든 트럭의 무게는 1 이상 weight 이하입니다.
 

입출력 예
bridge_length	weight	truck_weights	                    return
2	            10	    [7,4,5,6]	                        8
100	            100	    [10]	                            101
100	            100	    [10,10,10,10,10,10,10,10,10,10]	    110
*/

function solution(bridge_length, weight, truck_weights) {
    const bridge = Array.from({length : bridge_length}, _ => 0);
    let curWeight = 0;
    let time = 0;
    while(truck_weights.length){
        time++;
        curWeight -= bridge.shift();
        if(curWeight + truck_weights[0] > weight){
            bridge.push(0);
        } else {
            const curTruck = truck_weights.shift();
            bridge.push(curTruck);
            curWeight += curTruck;
        }
    }
    return time + bridge_length;
}

/*
먼저 현재 다리의 상태를 나타내는 bridge 라는 변수를 만듭니다.
이 bridge 라는 변수는 bridge_length 만큼의 길이에 모든 값이 0으로 초기화된 배열입니다.
즉, 0의 값을 가지면 트럭이 존재하지 않는 구간인것입니다.
예를들어,
[0, 0, 0] 상태이면 길이가 3인 다리에 아직 트럭이 하나도 올라오지 않은 상태이며
[0, 0, 7] 상태이면 무게 7인 트럭이 이제 막 진입한 상태이며, 1초가 지날 때 마다
[0, 0, 7] -> [0, 7, 0] -> [7, 0, 0]
이런식으로 진행되게 할 것입니다!
현재 다리 위에 존재하는 트럭들의 무게의 합을 담아둘 변수 curWeight와 지나는 시간을 담아둘 변수 time을 0으로 초기화 해둡니다.
이제 truck_weights 배열이 빌 때 까지, 즉 모든 트럭이 다리 위에 진입할 때 까지 반복문을 돌리기 시작합니다.
반복문이 진행될 때 마다 time을 1씩 증가시켜주고,
curWeight는 bridge 배열에 shift()를 한 값을 빼줍니다. 즉, 다리를 지나 나가는 트럭의 길이를 빼주는 것으로 현재 다리위에 존재하는 트럭들의 무게의 합을 변경해줍니다.
그리고 curWeight와 이제 다리로 진입할 차례인 트럭의 무게의 합이 다리가 견딜 수 있는 무게보다 크다면 bridge 배열의 맨 뒤에 0을 추가하는 것으로 다시 bridge의 길이를 다리길이로 맞춰줍니다.
다리가 견딜 수 있는 무게보다 작다면 진입할 차례인 트럭의 무게를 빼내어 다리의 맨 뒤에 넣어주고, 현재 다리 위의 총 트럭의 무게를 해당 값을 더해 증가시켜 줍니다.
위 반복문을 모두 반복하면 truck_weights가 비어있게 되고 반복문을 나오게 되고 time에는 마지막 차례의 트럭이 다리위로 진입한 시간이 담겨있습니다.
그리고 원하는 결과는 마지막 차례의 트럭이 다리를 통과한 시간이므로 진입을 하고 통과까지 걸리는 시간이 다리의 길이, 즉 bridge_length 일것이므로 time에 bridge_length 값을 더한 값을 반환하는 것으로 문제를 해결할 수 있습니다.
*/

/*
초기 설정:
bridge_length 길이로 초기화된 배열 bridge를 생성합니다. 이 배열은 다리를 표현하며, 초기 값은 0으로 설정됩니다.
현재 다리 위에 있는 트럭의 총 무게를 나타내는 변수 curWeight를 0으로 초기화합니다.
경과 시간을 나타내는 변수 time을 0으로 초기화합니다.

트럭 이동:
while 루프를 실행하여 truck_weights 배열에 트럭이 남아 있는 동안 반복합니다.
매 시간마다 time을 1씩 증가시킵니다.
현재 다리를 지나가고 있는 트럭의 무게를 curWeight에서 빼줍니다. (다리의 맨 앞 트럭을 제거)
다음에 진입할 트럭의 무게와 현재 다리 위의 트럭들의 무게 합이 weight를 초과하는지 확인합니다.
초과할 경우, 다리에 트럭을 진입시키지 않고 0을 추가하여 표시합니다. (다리의 맨 뒤에 0 추가)
초과하지 않을 경우, truck_weights 배열에서 다음 트럭을 꺼내어 다리에 진입시키고, curWeight에 해당 트럭의 무게를 추가합니다.

결과 반환:
모든 트럭이 다리를 지나면 time에 bridge_length를 더하여 최종 결과인 트럭들의 최소 소요 시간을 계산합니다.
이 값을 반환합니다.
*/