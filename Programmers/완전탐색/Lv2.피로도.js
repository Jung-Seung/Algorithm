/*
문제 설명
XX게임에는 피로도 시스템(0 이상의 정수로 표현합니다)이 있으며, 일정 피로도를 사용해서 던전을 탐험할 수 있습니다. 이때, 각 던전마다 탐험을 시작하기 위해 필요한 "최소 필요 피로도"와 던전 탐험을 마쳤을 때 소모되는 "소모 피로도"가 있습니다. "최소 필요 피로도"는 해당 던전을 탐험하기 위해 가지고 있어야 하는 최소한의 피로도를 나타내며, "소모 피로도"는 던전을 탐험한 후 소모되는 피로도를 나타냅니다. 예를 들어 "최소 필요 피로도"가 80, "소모 피로도"가 20인 던전을 탐험하기 위해서는 유저의 현재 남은 피로도는 80 이상 이어야 하며, 던전을 탐험한 후에는 피로도 20이 소모됩니다.

이 게임에는 하루에 한 번씩 탐험할 수 있는 던전이 여러개 있는데, 한 유저가 오늘 이 던전들을 최대한 많이 탐험하려 합니다. 유저의 현재 피로도 k와 각 던전별 "최소 필요 피로도", "소모 피로도"가 담긴 2차원 배열 dungeons 가 매개변수로 주어질 때, 유저가 탐험할수 있는 최대 던전 수를 return 하도록 solution 함수를 완성해주세요.

제한사항
- k는 1 이상 5,000 이하인 자연수입니다.
- dungeons의 세로(행) 길이(즉, 던전의 개수)는 1 이상 8 이하입니다.
    - dungeons의 가로(열) 길이는 2 입니다.
    - dungeons의 각 행은 각 던전의 ["최소 필요 피로도", "소모 피로도"] 입니다.
    - "최소 필요 피로도"는 항상 "소모 피로도"보다 크거나 같습니다.
    - "최소 필요 피로도"와 "소모 피로도"는 1 이상 1,000 이하인 자연수입니다.
    - 서로 다른 던전의 ["최소 필요 피로도", "소모 피로도"]가 서로 같을 수 있습니다.

입출력 예
k	dungeons	                result
80	[[80,20],[50,40],[30,10]]	3

입출력 예 설명
현재 피로도는 80입니다.

만약, 첫 번째 → 두 번째 → 세 번째 던전 순서로 탐험한다면
- 현재 피로도는 80이며, 첫 번째 던전을 돌기위해 필요한 "최소 필요 피로도" 또한 80이므로, 첫 번째 던전을 탐험할 수 있습니다. 첫 번째 던전의 "소모 피로도"는 20이므로, 던전을 탐험한 후 남은 피로도는 60입니다.
- 남은 피로도는 60이며, 두 번째 던전을 돌기위해 필요한 "최소 필요 피로도"는 50이므로, 두 번째 던전을 탐험할 수 있습니다. 두 번째 던전의 "소모 피로도"는 40이므로, 던전을 탐험한 후 남은 피로도는 20입니다.
- 남은 피로도는 20이며, 세 번째 던전을 돌기위해 필요한 "최소 필요 피로도"는 30입니다. 따라서 세 번째 던전은 탐험할 수 없습니다.

만약, 첫 번째 → 세 번째 → 두 번째 던전 순서로 탐험한다면
- 현재 피로도는 80이며, 첫 번째 던전을 돌기위해 필요한 "최소 필요 피로도" 또한 80이므로, 첫 번째 던전을 탐험할 수 있습니다. 첫 번째 던전의 "소모 피로도"는 20이므로, 던전을 탐험한 후 남은 피로도는 60입니다.
- 남은 피로도는 60이며, 세 번째 던전을 돌기위해 필요한 "최소 필요 피로도"는 30이므로, 세 번째 던전을 탐험할 수 있습니다. 세 번째 던전의 "소모 피로도"는 10이므로, 던전을 탐험한 후 남은 피로도는 50입니다.
- 남은 피로도는 50이며, 두 번째 던전을 돌기위해 필요한 "최소 필요 피로도"는 50이므로, 두 번째 던전을 탐험할 수 있습니다. 두 번째 던전의 "소모 피로도"는 40이므로, 던전을 탐험한 후 남은 피로도는 10입니다.

따라서 이 경우 세 던전을 모두 탐험할 수 있으며, 유저가 탐험할 수 있는 최대 던전 수는 3입니다.
*/

// 방법 1
function solution(k, dungeons) {
    var answer = 0;
    // 방문했는지 확인하기 위한 배열
    const come = Array.from({length : dungeons.length}, () => 0);

    // 완전탐색을 위한 dfs(남은 피로도, 진행단계)
    function dfs(hp, stage){
        // 던전의 수 만큼 반복
        for(let i=0;i<dungeons.length;i++){
            // 방문하지 않고 현재 남은 피로도가 최소 필요도 보다 크거나 같으면 실행
            if(!come[i] && dungeons[i][0] <= hp){
                // 현재 들어온 던전 방문 처리
                come[i] = 1
                // dfs(현재 피로도 - 방문 던전, 진행단계 + 1)
                dfs(hp - dungeons[i][1], stage + 1)
                // dfs 종료 후 방문을 끝낸다
                come[i] = 0
            }
        }
        // 가장 깊이 간 진행단계를 answer 에 넣는다
        answer = Math.max(answer, stage)
    }
    dfs(k, 0)
    
    return answer;
}

/*
먼저, come 배열을 생성하여 던전을 방문했는지를 표시하기 위한 용도로 사용합니다. 던전의 수만큼 come 배열을 0으로 초기화합니다.

dfs 함수는 깊이 우선 탐색(DFS)을 이용하여 모든 가능한 던전 탐험 방법을 확인합니다. dfs 함수는 현재 남은 피로도(hp)와 현재까지 진행한 던전 개수(stage)를 인자로 받습니다.

함수 내부에서는 던전의 수만큼 반복하면서 방문하지 않았고, 현재 남은 피로도가 던전의 필요 피로도보다 크거나 같은 경우 해당 던전을 탐험합니다.

탐험이 가능하다면, 해당 던전을 방문 처리하고, 현재 피로도에서 해당 던전의 피로도를 뺀 값을 새로운 hp로 전달하고, 진행 단계를 1 증가시킨 채로 재귀 호출합니다.

모든 가능한 던전 탐험 방법을 확인하면서 최대로 탐험할 수 있는 던전 개수를 answer에 저장합니다.

탐험 가능한 모든 방법을 확인한 후, answer를 반환하여 최대 탐험 가능 던전 개수를 구합니다.
*/

// 방법 2
function solution(k, dungeons){
    var answer = -1;
    // 현재 탐험한 던전을 체크하는 변수 (checked) 생성
    const checked = new Array(dungeons.length).fill(false);
    // 던전을 순서대로 입장하여 가장 많은 던전을 돌았을 때의 수를 찾을 수 있도록 완전탐색(DFS)
    enterDungeungs(k);
    
    function enterDungeungs(k, count = 0){
        for(let i=0;i<dungeons.length;i++){
            if(!checked[i] && k >= dungeons[i][0]){
                checked[i]=true;
                enterDungeungs(k - dungeons[i][1], count + 1);
                checked[i] = false;
            }
        }
        answer = answer < count ? count : answer;
    }
    // 완전탐색을 통해 얻은 최대로 많은 던전을 돌았을 때의 결과를 반환
    return answer;
}

/*
먼저, checked 배열을 생성하여 던전을 방문했는지를 표시하기 위한 용도로 사용합니다. 던전의 수만큼 checked 배열을 false로 초기화합니다.

enterDungeungs 함수는 현재 남은 피로도(k)와 현재까지 탐험한 던전 개수(count)를 인자로 받습니다. 기본값으로 count는 0으로 초기화됩니다.

함수 내부에서는 던전의 수만큼 반복하면서 방문하지 않았고, 현재 남은 피로도가 던전의 필요 피로도보다 크거나 같은 경우 해당 던전을 탐험합니다.

탐험이 가능하다면, 해당 던전을 방문 처리하고, 현재 피로도에서 해당 던전의 피로도를 뺀 값을 새로운 k로 전달하고, 탐험한 던전 개수를 1 증가시킨 채로 재귀 호출합니다.

모든 가능한 던전 탐험 방법을 확인하면서 가장 많이 탐험할 수 있는 던전 개수를 answer에 업데이트합니다.

탐험 가능한 모든 방법을 확인한 후, answer를 반환하여 최대 탐험 가능 던전 개수를 구합니다.
*/