/*
문제 설명
하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.

예를들어

- 0ms 시점에 3ms가 소요되는 A작업 요청
- 1ms 시점에 9ms가 소요되는 B작업 요청
- 2ms 시점에 6ms가 소요되는 C작업 요청
와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.
Screen Shot 2018-09-13 at 6.34.58 PM.png

한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.
Screen Shot 2018-09-13 at 6.38.52 PM.png

- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)
- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)
- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)
이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다.

하지만 A → C → B 순서대로 처리하면
Screen Shot 2018-09-13 at 6.41.42 PM.png

- A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)
- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)
- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)
이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다.

각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다)

제한 사항
- jobs의 길이는 1 이상 500 이하입니다.
- jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.
- 각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.
- 각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.
- 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.
*/

function solution(jobs) {
    const N = jobs.length;
    let curTime = 0, allTakeTime = 0;
    
    // 작업 리스트(jobs)를 작업 요청 시간을 기준으로 오름차순 정렬
    jobs.sort((a, b) => a[0] - b[0]);
    
    // jobs를 모두 순회
    while(jobs.length > 0){
        // 현재 시각에 작업할 수 있는 작업에 대하여 작업 소요 시간이 가장 짧은 작업을 찾는다
        let curJob = [-1, 1001, 1001];
        for(let j = 0; j < jobs.length; j++){
            if(curTime >= jobs[j][0]){
                if(curJob[1] > jobs[j][1]){
                    curJob = [j, jobs[j][1], jobs[j][1] + curTime - jobs[j][0]];
                }
            } else {
                break;
            }
        }
        // 위 기준으로 찾은 작업이 있을 경우 그 작업을 수행
        if(curJob[0] !== -1){
            // 작업 수행 후 현재 시각을 업데이트
            curTime += curJob[1];
            // 작업 수행 후 모든 작업에 대한 요청부터 종료까지의 총 시간을 합산
            allTakeTime += curJob[2];
            jobs.splice(curJob[0], 1);
        } else {
            // 위 기준으로 찾은 작업이 없을 경우 현재 시각을 가장 요청 시간이 빠른 작업 시간으로 업데이트
            curTime = jobs[0][0];
        }
    }
    
    // 위 순회를 통해 합산한 모든 작업에 대한 요청부터 종료까지의 총 시간의 평균을 반환
    return Math.floor(allTakeTime / N);
}

/*
초기화:
N: 작업의 총 개수를 나타내는 변수로, jobs 배열의 길이를 저장합니다.
curTime: 현재 시각을 나타내는 변수로, 작업을 처리하는 시간을 관리합니다.
allTakeTime: 모든 작업의 요청부터 종료까지 총 소요 시간을 나타내는 변수로, 초기값은 0으로 설정합니다.

작업 리스트 정렬:
jobs 배열을 작업 요청 시간을 기준으로 오름차순으로 정렬합니다.

작업 처리:
while 루프를 사용하여 모든 작업을 순회하면서 작업을 처리합니다.
현재 시각 curTime에 작업을 수행할 수 있는 작업들 중 작업 소요 시간이 가장 짧은 작업을 찾습니다.
이 작업을 curJob 변수에 저장합니다. curJob 배열은 [작업 인덱스, 작업 소요 시간, 작업 완료까지의 총 소요 시간]으로 구성됩니다.

작업 처리 및 업데이트:
만약 curJob[0]이 -1이 아닌 경우 (유효한 작업을 찾은 경우), 해당 작업을 수행합니다.
작업을 수행한 뒤 현재 시각 curTime을 업데이트하고, 모든 작업에 대한 요청부터 종료까지의 총 소요 시간인 allTakeTime에 curJob[2]를 더합니다.
수행한 작업은 jobs 배열에서 제거합니다.

작업 처리 불가능한 경우:
curJob[0]이 -1인 경우 (작업을 처리할 수 없는 경우), 현재 시각 curTime을 가장 요청 시간이 빠른 작업의 요청 시간으로 업데이트합니다.

최종 결과 반환:
모든 작업을 순회한 후, 모든 작업에 대한 요청부터 종료까지의 총 시간인 allTakeTime을 작업 개수 N으로 나누어 평균 대기 시간을 구합니다.
Math.floor 함수를 사용하여 소수점 이하를 버리고 정수 값을 반환합니다.
*/

/*
먼저, jobs 리스트를 작업 요청 시간을 기준으로 오름차순 정렬합니다. 이렇게 정렬된 리스트는 작업 요청 시간이 빠른 순서대로 작업이 처리됩니다.

그런 다음, curTime 변수를 사용하여 현재 시각을 표시합니다. 초기에는 0으로 설정합니다. allTakeTime 변수는 모든 작업에 대한 요청부터 종료까지의 총 시간을 합산하는 변수로, 초기에는 0으로 설정합니다.

while 루프를 이용하여 jobs 리스트를 순회합니다. 루프가 돌면서 현재 시각에 작업할 수 있는 작업 중 작업 소요 시간이 가장 짧은 작업을 찾습니다. 
이를 위해 curJob 변수에는 [인덱스, 작업 소요 시간, 총 소요 시간]을 저장합니다. curTime과 작업의 요청 시간을 비교하여 현재 시각 이후에 요청된 작업 중 소요 시간이 가장 짧은 작업을 찾습니다.

작업을 찾으면 해당 작업을 수행하고, 현재 시각을 업데이트합니다. 그리고 모든 작업에 대한 요청부터 종료까지의 총 시간 allTakeTime에 이 작업의 총 소요 시간을 합산합니다. 마지막으로, 해당 작업을 jobs 리스트에서 제거합니다.

만약 현재 시각 이후에 작업을 수행할 수 있는 작업이 없다면, 현재 시각을 가장 먼저 요청된 작업의 요청 시간으로 업데이트합니다.

위 과정을 jobs 리스트의 모든 작업을 처리할 때까지 반복합니다.

최종적으로, 모든 작업에 대한 요청부터 종료까지의 총 시간 allTakeTime을 작업 개수 N으로 나눈 후, Math.floor를 이용하여 평균 대기 시간을 구합니다. 
이 값을 반환하여 결과를 얻습니다. 이로써 주어진 jobs 리스트를 이용하여 평균 대기 시간을 구하는 함수가 완성됩니다.
*/